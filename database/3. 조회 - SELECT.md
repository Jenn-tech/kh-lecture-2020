# 목차

- [목차](#목차)
- [1. SELECT](#1-select)
  - [1.1. 실습 전 확인사항](#11-실습-전-확인사항)
  - [1.2. 데이터를 조회하는 방법](#12-데이터를-조회하는-방법)
    - [1.2.1. 셀렉션](#121-셀렉션)
    - [1.2.2. 프로젝션](#122-프로젝션)
    - [1.2.3. 조인](#123-조인)
  - [1.3. 조회 쿼리의 기본 - SELECT 절, FROM 절](#13-조회-쿼리의-기본---select-절-from-절)
    - [1.3.1. 전체 열을 조회](#131-전체-열을-조회)
    - [1.3.2. 일부 열을 조회](#132-일부-열을-조회)
  - [1.4. 중복 제거 - DISTINCT](#14-중복-제거---distinct)
    - [1.4.1. 열이 하나인 경우](#141-열이-하나인-경우)
    - [1.4.2. 열이 두 개 이상인 경우](#142-열이-두-개-이상인-경우)
    - [1.4.3. 별칭(alias) - AS](#143-별칭alias---as)
    - [1.4.4. 정렬 - ORDER BY](#144-정렬---order-by)
- [2. WHERE clause and operators](#2-where-clause-and-operators)
- [3. Oracle functions](#3-oracle-functions)
- [4. aggregation, group](#4-aggregation-group)
- [5. join](#5-join)
- [6. Subquery](#6-subquery)

# 1. SELECT

데이터 조회에 가장 기본적인 `SELECT`문을 학습한다.  

## 1.1. 실습 전 확인사항

우리가 세팅한 환경에는 직원을 나타내는 employee 테이블과 부서를 나타내는 department 테이블이 존재한다.  

우선 emplyee 테이블은 다음과 같다.  

|column name|column desc|type|description|
|-|-|-|-|
|id|직원번호|NUMBER|emplyee 테이블의 기본키|
|name|직원 이름|VARCHAR2(32)|32글자 제한이 있는 문자열|
|job|직무|VARCHAR2(8)|8글자 제한이 있는 문자열|
|manager_id|매니저의 직원번호|NUMBER|employee를 나타내는 외래키|
|hired_date|입사일|TIMESTAMP|날짜 데이터|
|salary|급여|FLOAT|소수점 데이터|
|commission|인센티브|FLOAT|소수점 데이터|
|department_id|부서 번호|NUMBER|department를 나타내는 외래키|

그 다음은 부서를 나타내는 테이블이다.  

|column name|column desc|type|description|
|-|-|-|-|
|id|부서번호|NUMBER|department 테이블의 기본키|
|department_name|부서명|VARCHAR2(16)|16글자 제한이 있는 문자열|
|location|부서위치|VARCHAR2(16)|16글자 제한이 있는 문자열|

## 1.2. 데이터를 조회하는 방법

데이터 조회에는 크게 세 가지 방법이 존재한다.  

- 셀렉션(selection)
- 프로젝션(projection)
- 조인(join)

### 1.2.1. 셀렉션

셀렉션은 행을 선택하는 방식을 의미한다. 가령 다음과 같다.  
다음 SQL을 실행시켜보자.  

```sql
> SELECT * FROM employee;
```

결과는 다음과 같다.  

| ID | COMMISSION | HIRED_DATE | JOB | NAME | SALARY | DEPARTMENT_ID | MANAGER_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 2 | 10 | 2020-10-11 05:18:51.552553 | design | 주호민 | 1000 | 1 | NULL |

위와 같은 경우 전체 테이블을 조회한다.  
다음과 같이 특정 직원의 이름으로 검색하고 싶다면?  

```sql
> SELECT * FROM employee WHERE name = '주호민';
```

### 1.2.2. 프로젝션

셀렉션이 `행(row)`을 선택하는 것이였다면 프로젝션은 `열(column)`을 선택하는 방식을 의미한다.  
직원 테이블에서 직원의 이름과 입사일만 추출하고 싶다면 다음과 같이 한다.  

```sql
> SELECT name, hired_date FROM employee;
```

결과는 다음과 같다.  

| NAME | HIRED_DATE |
| :--- | :--- |
| 주호민 | 2020-10-11 05:18:51.552553 |

참고로 특정 조건을 만족하는 행들을 선택하고, 추출된 행들에서 특정한 열만 보고 싶다면 다음과 같이 하면 된다.  

```sql
> SELECT name, hired_date FROM employee WHERE name = '주호민';
```

이렇게 하면 다음과 같은 동작을 기대할 수 있다.  

1. `주호민`이라는 이름을 가진 직원의 행을 추출한다.
2. 이 행에서 이름과 입사일만 추출한다.

이렇게 하면 주호민이라는 이름을 가진 레코드에서 이름과 입사일만 추출해서 볼 수 있다.  

### 1.2.3. 조인

두 개 이상의 테이블을 연결해 하나의 테이블처럼 조회하는 방식이다. 물론 조인의 결과로 나온 테이블은 실제로 존재하는 것이 아니다.  

직원테이블과 부서테이블을 조인하여 특정 부서에 근무중인 직원만 추출하고 싶다면 다음과 같이 하면 된다.  

```sql
SELECT e.*
  FROM employee e
  JOIN department d 
       ON e.DEPARTMENT_ID = d.ID
 WHERE d.DEPARTMENT_NAME = 'design'
```

## 1.3. 조회 쿼리의 기본 - SELECT 절, FROM 절

SELECT 문(select statement)은 DB에 보관된 데이터를 조회하는데 사용한다.  

다음 SELECT 문을 살펴보자.  

```sql
SELECT foo FROM bar JOIN boo WHERE x = y;
```

이 문장은 다음과 같은 절(clause)들로 구성이 되어 있다.  

- WHERE x = y
- SELECT foo
- FROM bar
- JOIN boo

여기서는 SELECT 절과 FROM 절을 살펴볼 것이다. 우선 SELECT 문장을 일반화 시켜서 기억해두자.  

```sql
SELECT [col 1], [col 2], ..., [col n]
  FROM table_name
```

|키워드|요소|설명|
|-|-|-|
|SELECT|조회할 열들|조회할 열을 지정한다. 애스터리스크(*)를 사용하면 전체를 의미|
|FROM|조회할 테이블|FROM 조회할 테이블을 지정한다.|

### 1.3.1. 전체 열을 조회

전체 열을 조회하려면 애스터리스크(*)를 사용하면 된다.  

```sql
SELECT * FROM employee;
```

### 1.3.2. 일부 열을 조회

일부 열을 조회하려면 칼럼 이름을 지정해주면 된다.

```sql
SELECT name, hired_date FROM employee;
```

## 1.4. 중복 제거 - DISTINCT

열의 중복된 값들을 제거하기 위해 사용한다.  
테이블에 값이 다음과 같이 저장되어 있다고 가정해보자.  

| ID | COMMISSION | HIRED_DATE | JOB | NAME | SALARY | DEPARTMENT_ID | MANAGER_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 4 | 10 | 2020-10-11 20:52:48.548930 | design | 주호민 | 1000 | 1 | NULL |
| 5 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 2 | NULL |
| 6 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 3 | NULL |
| 7 | 10 | 2020-10-11 20:52:48.548930 | programmer | 주호민 | 1000 | 2 | NULL |
| 8 | 10 | 2020-10-11 20:52:48.548930 | webdev | 주호민 | 1000 | 3 | NULL |

### 1.4.1. 열이 하나인 경우

위 테이블에서 departmenet_id의 중복을 해보자.  

```sql
SELECT DISTINCT DEPARTMENT_ID FROM employee;
```

이렇게 하면 직원이 어느 부서에 있는지 모아서 볼 수 있다.  
숫자가 불편해서 이름을 같이 보고 싶다면 다음과 같이 하면 된다.  

```sql
SELECT DISTINCT e.DEPARTMENT_ID, d.DEPARTMENT_NAME
  FROM employee e
  JOIN department d on e.DEPARTMENT_ID = d.ID;
```

### 1.4.2. 열이 두 개 이상인 경우

선택된 열이 두 개 이상인 경우에 어떤 동작을 보이는지 알아보자.  

```sql
SELECT DISTINCT job, department_id FROM employee;
```

결과는 다음과 같다.  

| JOB | DEPARTMENT_ID |
| :--- | :--- |
| design | 1 |
| programmer | 2 |
| programmer | 3 |
| webdev | 3 |

job 칼럼이 여러번 출력되고 있다.  

### 1.4.3. 별칭(alias) - AS

다음과 같이 부서에 몇 명이 있는지 알아내보자.  


```sql
SELECT d.DEPARTMENT_NAME, count(*)
FROM employee e
         JOIN department d ON e.DEPARTMENT_ID = d.ID
GROUP BY d.DEPARTMENT_NAME
```

결과를 살펴보자.  

| DEPARTMENT\_NAME | COUNT\(\*\) |
| :--- | :--- |
| frontend development | 2 |
| backend development | 2 |
| design | 1 |

여기서 보면 열의 이름이 `count(*)`인 것을 알 수 있다. 이와 같이 열의 이름은 연산식이 그대로 출력되어 직관적이지 않은 것을 알 수 있다.  

이 때 사용하는 것이 바로 별칭이다. 별칭을 지정하면 직관적인 이름을 지정해줄 수 있다.  

```sql
SELECT d.DEPARTMENT_NAME, count(*) AS 사원수
FROM employee e
         JOIN department d ON e.DEPARTMENT_ID = d.ID
GROUP BY d.DEPARTMENT_NAME
```

결과를 살펴보자.

| DEPARTMENT\_NAME | 사원수 |
| :--- | :--- |
| frontend development | 2 |
| backend development | 2 |
| design | 1 |

이렇게 하면 부서 별 사원수를 나타내는 정보라는 것을 한 눈에 파악할 수 있게 된다.  

이제 일반화 시켜서 기억해보자. 네 가지 방법이 존재하는데 마지막 방법만 기억하면 된다. 이유는 뒤에서 설명한다.  

|예시|설명|
|-|-|
|연산식 별칭|연산식 [공백] 별칭|
|연산식 "별칭"|연산식 [공백] "별칭". 유의할 점은 큰 따옴표를 사용함|
|연산식 AS "별칭"|연산식 AS "별칭". 유의할 점은 큰 따옴표를 사용함|
|연산식 AS 별칭|연산식 AS 별칭. 큰 따옴표를 사용하지 않음|

마지막 방법을 가장 많이 사용하는 이유는 다음과 같다.  

1. AS를 사용하면 어떤 별칭을 지정했는지 구분하기 편하다. (도구 지원)
2. 개발 시 문자열 처리가 편하다.

### 1.4.4. 정렬 - ORDER BY

문장의 가장 마지막에 정렬을 위한 ORDER BY 절을 사용한다.  
사용 방식은 다음과 같다.  

```sql
  SELECT [col 1], [col 2], ..., [col n]
    FROM table_name
ORDER BY [col...] [opt]
```

정렬하려는 열과 정렬 방식을 지정할 수 있다. 정렬 방식은 두 가지가 존재한다.  

- ASC: 오름차순. 기본값
- DESC: 내림차순

참고로 정렬은 추가적인 코스트가 발생하므로 유의해서 사용해야한다.  

# 2. WHERE clause and operators

# 3. Oracle functions

# 4. aggregation, group

# 5. join

# 6. Subquery