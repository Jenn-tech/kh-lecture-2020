# 목차

- [목차](#목차)
- [1. SELECT](#1-select)
  - [1.1. 실습 전 확인사항](#11-실습-전-확인사항)
  - [1.2. 데이터를 조회하는 방법](#12-데이터를-조회하는-방법)
    - [1.2.1. 셀렉션](#121-셀렉션)
    - [1.2.2. 프로젝션](#122-프로젝션)
    - [1.2.3. 조인](#123-조인)
  - [1.3. 조회 쿼리의 기본 - SELECT 절, FROM 절](#13-조회-쿼리의-기본---select-절-from-절)
    - [1.3.1. 전체 열을 조회](#131-전체-열을-조회)
    - [1.3.2. 일부 열을 조회](#132-일부-열을-조회)
  - [1.4. 중복 제거 - DISTINCT](#14-중복-제거---distinct)
    - [1.4.1. 열이 하나인 경우](#141-열이-하나인-경우)
    - [1.4.2. 열이 두 개 이상인 경우](#142-열이-두-개-이상인-경우)
    - [1.4.3. 별칭(alias) - AS](#143-별칭alias---as)
    - [1.4.4. 정렬 - ORDER BY](#144-정렬---order-by)
- [2. WHERE 절과 연산자](#2-where-절과-연산자)
  - [2.1. WHERE 절](#21-where-절)
  - [2.2. AND, OR](#22-and-or)
  - [2.3. 그 외 연산자](#23-그-외-연산자)
    - [2.3.1. LIKE](#231-like)
    - [2.3.1. IS NULL](#231-is-null)
    - [2.3.2. 집합연산](#232-집합연산)
- [3. Oracle functions](#3-oracle-functions)
- [4. aggregation, group](#4-aggregation-group)
- [5. join](#5-join)
- [6. Subquery](#6-subquery)

# 1. SELECT

데이터 조회에 가장 기본적인 `SELECT`문을 학습한다.  

## 1.1. 실습 전 확인사항

우리가 세팅한 환경에는 직원을 나타내는 employee 테이블과 부서를 나타내는 department 테이블이 존재한다.  

우선 emplyee 테이블은 다음과 같다.  

|column name|column desc|type|description|
|-|-|-|-|
|id|직원번호|NUMBER|emplyee 테이블의 기본키|
|name|직원 이름|VARCHAR2(32)|32글자 제한이 있는 문자열|
|job|직무|VARCHAR2(8)|8글자 제한이 있는 문자열|
|manager_id|매니저의 직원번호|NUMBER|employee를 나타내는 외래키|
|hired_date|입사일|TIMESTAMP|날짜 데이터|
|salary|급여|FLOAT|소수점 데이터|
|commission|인센티브|FLOAT|소수점 데이터|
|department_id|부서 번호|NUMBER|department를 나타내는 외래키|

그 다음은 부서를 나타내는 테이블이다.  

|column name|column desc|type|description|
|-|-|-|-|
|id|부서번호|NUMBER|department 테이블의 기본키|
|department_name|부서명|VARCHAR2(16)|16글자 제한이 있는 문자열|
|location|부서위치|VARCHAR2(16)|16글자 제한이 있는 문자열|

## 1.2. 데이터를 조회하는 방법

데이터 조회에는 크게 세 가지 방법이 존재한다.  

- 셀렉션(selection)
- 프로젝션(projection)
- 조인(join)

### 1.2.1. 셀렉션

셀렉션은 행을 선택하는 방식을 의미한다. 가령 다음과 같다.  
다음 SQL을 실행시켜보자.  

```sql
> SELECT * FROM employee;
```

결과는 다음과 같다.  

| ID | COMMISSION | HIRED_DATE | JOB | NAME | SALARY | DEPARTMENT_ID | MANAGER_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 2 | 10 | 2020-10-11 05:18:51.552553 | design | 주호민 | 1000 | 1 | NULL |

위와 같은 경우 전체 테이블을 조회한다.  
다음과 같이 특정 직원의 이름으로 검색하고 싶다면?  

```sql
> SELECT * FROM employee WHERE name = '주호민';
```

### 1.2.2. 프로젝션

셀렉션이 `행(row)`을 선택하는 것이였다면 프로젝션은 `열(column)`을 선택하는 방식을 의미한다.  
직원 테이블에서 직원의 이름과 입사일만 추출하고 싶다면 다음과 같이 한다.  

```sql
> SELECT name, hired_date FROM employee;
```

결과는 다음과 같다.  

| NAME | HIRED_DATE |
| :--- | :--- |
| 주호민 | 2020-10-11 05:18:51.552553 |

참고로 특정 조건을 만족하는 행들을 선택하고, 추출된 행들에서 특정한 열만 보고 싶다면 다음과 같이 하면 된다.  

```sql
> SELECT name, hired_date FROM employee WHERE name = '주호민';
```

이렇게 하면 다음과 같은 동작을 기대할 수 있다.  

1. `주호민`이라는 이름을 가진 직원의 행을 추출한다.
2. 이 행에서 이름과 입사일만 추출한다.

이렇게 하면 주호민이라는 이름을 가진 레코드에서 이름과 입사일만 추출해서 볼 수 있다.  

### 1.2.3. 조인

두 개 이상의 테이블을 연결해 하나의 테이블처럼 조회하는 방식이다. 물론 조인의 결과로 나온 테이블은 실제로 존재하는 것이 아니다.  

직원테이블과 부서테이블을 조인하여 특정 부서에 근무중인 직원만 추출하고 싶다면 다음과 같이 하면 된다.  

```sql
SELECT e.*
  FROM employee e
  JOIN department d 
       ON e.DEPARTMENT_ID = d.ID
 WHERE d.DEPARTMENT_NAME = 'design'
```

## 1.3. 조회 쿼리의 기본 - SELECT 절, FROM 절

SELECT 문(select statement)은 DB에 보관된 데이터를 조회하는데 사용한다.  

다음 SELECT 문을 살펴보자.  

```sql
SELECT foo FROM bar JOIN boo WHERE x = y;
```

이 문장은 다음과 같은 절(clause)들로 구성이 되어 있다.  

- WHERE x = y
- SELECT foo
- FROM bar
- JOIN boo

여기서는 SELECT 절과 FROM 절을 살펴볼 것이다. 우선 SELECT 문장을 일반화 시켜서 기억해두자.  

```sql
SELECT [col 1], [col 2], ..., [col n]
  FROM table_name
```

|키워드|요소|설명|
|-|-|-|
|SELECT|조회할 열들|조회할 열을 지정한다. 애스터리스크(*)를 사용하면 전체를 의미|
|FROM|조회할 테이블|FROM 조회할 테이블을 지정한다.|

### 1.3.1. 전체 열을 조회

전체 열을 조회하려면 애스터리스크(*)를 사용하면 된다.  

```sql
SELECT * FROM employee;
```

### 1.3.2. 일부 열을 조회

일부 열을 조회하려면 칼럼 이름을 지정해주면 된다.

```sql
SELECT name, hired_date FROM employee;
```

## 1.4. 중복 제거 - DISTINCT

열의 중복된 값들을 제거하기 위해 사용한다.  
테이블에 값이 다음과 같이 저장되어 있다고 가정해보자.  

| ID | COMMISSION | HIRED_DATE | JOB | NAME | SALARY | DEPARTMENT_ID | MANAGER_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 4 | 10 | 2020-10-11 20:52:48.548930 | design | 주호민 | 1000 | 1 | NULL |
| 5 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 2 | NULL |
| 6 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 3 | NULL |
| 7 | 10 | 2020-10-11 20:52:48.548930 | programmer | 주호민 | 1000 | 2 | NULL |
| 8 | 10 | 2020-10-11 20:52:48.548930 | webdev | 주호민 | 1000 | 3 | NULL |

### 1.4.1. 열이 하나인 경우

위 테이블에서 departmenet_id의 중복을 해보자.  

```sql
SELECT DISTINCT DEPARTMENT_ID FROM employee;
```

이렇게 하면 직원이 어느 부서에 있는지 모아서 볼 수 있다.  
숫자가 불편해서 이름을 같이 보고 싶다면 다음과 같이 하면 된다.  

```sql
SELECT DISTINCT e.DEPARTMENT_ID, d.DEPARTMENT_NAME
  FROM employee e
  JOIN department d on e.DEPARTMENT_ID = d.ID;
```

### 1.4.2. 열이 두 개 이상인 경우

선택된 열이 두 개 이상인 경우에 어떤 동작을 보이는지 알아보자.  

```sql
SELECT DISTINCT job, department_id FROM employee;
```

결과는 다음과 같다.  

| JOB | DEPARTMENT_ID |
| :--- | :--- |
| design | 1 |
| programmer | 2 |
| programmer | 3 |
| webdev | 3 |

job 칼럼이 여러번 출력되고 있다.  

### 1.4.3. 별칭(alias) - AS

다음과 같이 부서에 몇 명이 있는지 알아내보자.  


```sql
SELECT d.DEPARTMENT_NAME, count(*)
FROM employee e
         JOIN department d ON e.DEPARTMENT_ID = d.ID
GROUP BY d.DEPARTMENT_NAME
```

결과를 살펴보자.  

| DEPARTMENT\_NAME | COUNT\(\*\) |
| :--- | :--- |
| frontend development | 2 |
| backend development | 2 |
| design | 1 |

여기서 보면 열의 이름이 `count(*)`인 것을 알 수 있다. 이와 같이 열의 이름은 연산식이 그대로 출력되어 직관적이지 않은 것을 알 수 있다.  

이 때 사용하는 것이 바로 별칭이다. 별칭을 지정하면 직관적인 이름을 지정해줄 수 있다.  

```sql
SELECT d.DEPARTMENT_NAME, count(*) AS 사원수
FROM employee e
         JOIN department d ON e.DEPARTMENT_ID = d.ID
GROUP BY d.DEPARTMENT_NAME
```

결과를 살펴보자.

| DEPARTMENT\_NAME | 사원수 |
| :--- | :--- |
| frontend development | 2 |
| backend development | 2 |
| design | 1 |

이렇게 하면 부서 별 사원수를 나타내는 정보라는 것을 한 눈에 파악할 수 있게 된다.  

이제 일반화 시켜서 기억해보자. 네 가지 방법이 존재하는데 마지막 방법만 기억하면 된다. 이유는 뒤에서 설명한다.  

|예시|설명|
|-|-|
|연산식 별칭|연산식 [공백] 별칭|
|연산식 "별칭"|연산식 [공백] "별칭". 유의할 점은 큰 따옴표를 사용함|
|연산식 AS "별칭"|연산식 AS "별칭". 유의할 점은 큰 따옴표를 사용함|
|연산식 AS 별칭|연산식 AS 별칭. 큰 따옴표를 사용하지 않음|

마지막 방법을 가장 많이 사용하는 이유는 다음과 같다.  

1. AS를 사용하면 어떤 별칭을 지정했는지 구분하기 편하다. (도구 지원)
2. 개발 시 문자열 처리가 편하다.

### 1.4.4. 정렬 - ORDER BY

문장의 가장 마지막에 정렬을 위한 ORDER BY 절을 사용한다.  
사용 방식은 다음과 같다.  

```sql
  SELECT [col 1], [col 2], ..., [col n]
    FROM table_name
ORDER BY [col...] [opt]
```

정렬하려는 열과 정렬 방식을 지정할 수 있다. 정렬 방식은 두 가지가 존재한다.  

- ASC: 오름차순. 기본값
- DESC: 내림차순

참고로 정렬은 추가적인 코스트가 발생하므로 유의해서 사용해야한다.  

# 2. WHERE 절과 연산자

WHERE 절은 데이터를 가져오기 위한 조건을 지정할 수 있게 해준다. 이 때 조건을 지정하기 위해 연산자가 필요하다.  

## 2.1. WHERE 절

WHERE 절을 사용하기 위한 형식은 다음과 같다.  

```sql
  SELECT [col 1], [col 2], ..., [col n]
    FROM table_name
   WHERE [condition]
```

직원 테이블에서 이름이 `주호민`인 사람을 찾아보자.  

```sql
SELECT * FROM employee WHERE name = '주호민';
```

조건인 name = '주호민'이 true인 모든 행을 선택해서 반환한다.  

## 2.2. AND, OR

조건식을 여러 개 지정할 때 적합한 연산자가 AND와 OR이다. 프로그래밍에서 등장하는 그 AND와 OR 연산이 맞다.  

가령 2020년 10월에 입사한 디자인팀 직원을 조회하고 싶다면 다음과 같이 쿼리를 작성하면 된다.  

```sql
SELECT e.*
  FROM EMPLOYEE e
         JOIN DEPARTMENT D ON D.ID = e.DEPARTMENT_ID
 WHERE d.DEPARTMENT_NAME = 'design'
         AND TO_CHAR(e.HIRED_DATE, 'YYYY-MM') = '2020-10';
```

## 2.3. 그 외 연산자

간단한 친구들은 표로 ~~때운다~~ 설명한다.  

|연산자 타입|키워드|예제|설명|
|-|-|-|-|
|산술|`+` `-` `*` `/`||가감승제. 필요할까..?|
|비교|`>` `>=` `<` `<=`||대소비교. 필요할까..?|
|등가비교|`!=` `<>` `^=`||xor|
|논리부정|`NOT`|WHERE NOT name = '주호민'|이름이 주호민이 아닌 사람|
|포함|`IN`|WHERE job IN ('programmer', 'manager')|직책이 프로그래머거나 매니저|
|범위|`BETWEEN [조건1] AND [조건2]`|WHERE salary BETWEEN 1000 AND 2000|급여가 1000과 2000사이|

### 2.3.1. LIKE

텍스트 칼럼에서 문자열을 검색할 때 사용한다. 보통 게시판에서 검색 기능을 구현할 때 사용하는데, 사실 성능 때문에 고민을 해봐야 한다. 레코드 수가 많아지면 성능이 매우 저하되기 때문에 다른 방법을 사용해야한다. 하지만 여기선 논외로한다.  

LIKE를 사용해보기에 앞서 사용할 수 있는 와일드카드에 대해 알아보자.  

|종류|설명|
|-|-|
|`_`|종류에 상관 없이 한 개의 문자|
|`%`|길이와 종류와 상관 없이 모든 문자|

이는 쿼리를 작성해보는 것이 이해에 빠르다.  

직원 중 `이`씨 성을 가진 외자이름 직원을 검색한다고 가정해보자.  

```sql
SELECT * FROM EMPLOYEE WHERE name LIKE '이_';
```

결과는 다음과 같다.  

| ID | COMMISSION | HIRED\_DATE | JOB | NAME | SALARY | DEPARTMENT\_ID | MANAGER\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 6 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이적 | 1000 | 3 | NULL |

직원 중 `이`씨 성을 가진 직원을 검색한다고 가정해보자.  

```sql
SELECT * FROM EMPLOYEE WHERE name LIKE '이%';
```

결과는 다음과 같다.

| ID | COMMISSION | HIRED\_DATE | JOB | NAME | SALARY | DEPARTMENT\_ID | MANAGER\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 5 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 2 | NULL |
| 6 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이적 | 1000 | 3 | NULL |

### 2.3.1. IS NULL

`IS NULL` 연산자는 값이 없는 칼럼을 조회한다. 칼럼에 `NOT NULL` 제약 조건이 없는 경우에 쓰면 된다. `NN` 제약이 걸려 있는 곳에 굳이 쓸 필요가 없다.  

직원 중 매니저가 없는 경우를 조회해보자.  

```sql
SELECT * FROM EMPLOYEE WHERE manager_id IS NULL;
```

결과는 다음과 같다.  


| ID | COMMISSION | HIRED\_DATE | JOB | NAME | SALARY | DEPARTMENT\_ID | MANAGER\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 4 | 10 | 2020-10-11 20:52:48.548930 | design | 주호민 | 1000 | 1 | NULL |
| 5 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 2 | NULL |
| 6 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이적 | 1000 | 3 | NULL |
| 7 | 10 | 2020-10-11 20:52:48.548930 | programmer | 주호민 | 1000 | 2 | NULL |
| 8 | 10 | 2020-10-11 20:52:48.548930 | webdev | 주호민 | 1000 | 3 | NULL |

### 2.3.2. 집합연산

관계형 데이터 모델은 집합론에서 파생된 개념이다. 우리가 앞서 공부한 조회는 실행의 결과로 결과셋(result set)을 반환하는 것을 확인하였다. 이 결과셋의 합집합, 차집합, 교집합을 구하는 연산을 학습해보자.  

(1) UNION

`UNION`은 결과셋을 합집합으로 묶어준다. `UNION ALL` 키워드와 구분되는 점은 `UNION ALL`은 중복제거를 하지 않는다. (엄밀한 정의의 집합과는 거리가 있지만)

아주 간단하게 다음 쿼리 두 개를 읽고 결과를 예측해보자.  

```sql
SELECT * FROM EMPLOYEE UNION SELECT * FROM EMPLOYEE;
SELECT * FROM EMPLOYEE UNION ALL SELECT * FROM EMPLOYEE;
```

각각의 결과는 다음과 같다.  

`UNION`의 결과

| ID | COMMISSION | HIRED\_DATE | JOB | NAME | SALARY | DEPARTMENT\_ID | MANAGER\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 4 | 10 | 2020-10-11 20:52:48.548930 | design | 주호민 | 1000 | 1 | NULL |
| 5 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 2 | NULL |
| 6 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이적 | 1000 | 3 | NULL |
| 7 | 10 | 2020-10-11 20:52:48.548930 | programmer | 주호민 | 1000 | 2 | NULL |
| 8 | 10 | 2020-10-11 20:52:48.548930 | webdev | 주호민 | 1000 | 3 | NULL |


`UNION ALL`의 결과

| ID | COMMISSION | HIRED\_DATE | JOB | NAME | SALARY | DEPARTMENT\_ID | MANAGER\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 4 | 10 | 2020-10-11 20:52:48.548930 | design | 주호민 | 1000 | 1 | NULL |
| 5 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 2 | NULL |
| 6 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이적 | 1000 | 3 | NULL |
| 7 | 10 | 2020-10-11 20:52:48.548930 | programmer | 주호민 | 1000 | 2 | NULL |
| 8 | 10 | 2020-10-11 20:52:48.548930 | webdev | 주호민 | 1000 | 3 | NULL |
| 4 | 10 | 2020-10-11 20:52:48.548930 | design | 주호민 | 1000 | 1 | NULL |
| 5 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이병건 | 1000 | 2 | NULL |
| 6 | 10 | 2020-10-11 20:52:48.548930 | programmer | 이적 | 1000 | 3 | NULL |
| 7 | 10 | 2020-10-11 20:52:48.548930 | programmer | 주호민 | 1000 | 2 | NULL |
| 8 | 10 | 2020-10-11 20:52:48.548930 | webdev | 주호민 | 1000 | 3 | NULL |

중복이 제거된 것을 볼 수 있다.  

고민해볼 것

> 같은 테이블 끼리만 가능할까?

# 3. Oracle functions

# 4. aggregation, group

# 5. join

# 6. Subquery